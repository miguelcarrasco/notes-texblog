---
title: Resolviendo relaciones de recurrencia usando álgebra lineal
date: "2022-10-06T00:12:20Z"
description: "Método para resolver relaciones de recurrencia usando álgebra lineal"
---

import Image from "../../src/components/Utils/image"

Una relación de recurrencia es una ecuación que define una secuencia recursiva;
cada término de la secuencia es definido como una función de términos anteriores.

Un ejemplo de una secuencia recursiva es la famosa secuencia de Fibonacci
en dónde cada término de la sucesión es la suma de los dos números anteriores

$$ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ... $$

La cual se puede escribir como

$$
\begin{aligned}
F_0 &= 0 \\
F_1 &= 1 \\
F_n &= F_{n-1} + F_{n-2}, \forall n \in \mathbb{N} \land n > 1
\end{aligned}
$$

Esta forma de escribirla resulta muy conveniente para programar una función recursiva
que calcule el valor de $F_n$ en algún lenguaje de programación, como por ejemplo en lenguaje C

```cpp
int fib(int n){
    if(n == 0){
        return 0;
    }

    if(n == 1){
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}
```
El gran inconveniente con esta implementación es que su complejidad algorítmica resulta ser exponencial.
Podemos observar que por cada llamada a esta función, la mayoría de las veces se "expanden" otras
dos llamadas. Por lo que su complejidad se acerca a $O(2^n)$. Por ejemplo para calcular fib(6), se tienen
que hacer 23 llamadas

<Image fileName="fibonacci.svg" className="small-image" alt="árbol de llamadas de la implementación recursiva de fibonacci" />

Una mejora en la implementación permite bajar la complejidad a $O(n)$, es decir, resolver el problema
en tiempo lineal. Como por ejemplo la función de recursión de cola (tail recursion) siguiente

```cpp
unsigned long fib(unsigned long n, unsigned long currentVal = 1, unsigned long previousVal = 0) {
    if (n == 0) {
        return previousVal;
    }

    if (n == 1) {
        return currentVal;
    }
    return fib(n - 1, currentVal + previousVal, currentVal);
}
```
Aun así queda la duda de si podría existir una implementación más eficiente

## La fórmula de Binet

Existen soluciones explícitas (también llamadas formas cerradas) a algunas relaciones de recurrencia. En el caso
de la secuencia de Fibonacci se le atribuye a [Jacques Philippe Marie Binet](https://en.wikipedia.org/w/index.php?title=Jacques_Philippe_Marie_Binet&oldid=1067689697)
la siguiente fórmula explícita para obtener $F_n$

$$ \boxed{ F_n = \frac{1}{\sqrt{5}} \left[ \left( \frac{1+\sqrt{5}}{2} \right)^n - \left( \frac{1-\sqrt{5}}{2} \right)^n \right] }$$

Otra forma de escribir esta fórmula es la siguiente

$$ \boxed{ F_n = \frac{1}{\sqrt{5}} \left[ \phi^n - \psi^n \right] } $$

donde $\phi=\frac{1+\sqrt{5}}{2}$ y $\psi=\frac{1-\sqrt{5}}{2}$

cuya implementación podría ser

```cpp
const long double FIVE_SQUARE = pow(5, 0.5);
const long double PHI = (1 + FIVE_SQUARE) / 2;
const long double PSI = (1 - FIVE_SQUARE) / 2;

unsigned long fib(unsigned long n) {
    return ((pow(PHI, n) - pow(PSI, n)) / FIVE_SQUARE);
}
```
La cual nos reduce la complejidad algorítmica aún más a $O(\log(n))$, ya que la manera más eficiente conocida de elevar
a la potencia $n$ tiene complejidad $O(\log(n))$. El único problema de esta implementación es que puede tener errores
de redondeo para $n$ grandes. En esta implementación en C++, a partir de $n > 71$ empiezan a aparecer errores de redondeo,
sin embargo es bastante interesante como es posible reducir la complejidad algorítmica con una fórmula explicita.

Es fácil demostrar que la fórmula de Binet se cumple para todo $n \in \mathbb{N} \cup \{0\}$ usando
[inducción fuerte](https://en.wikipedia.org/wiki/Mathematical_induction#Complete_(strong)_induction).

Para $n=0$ vemos que se cumple

$$
F_0 = \frac{1}{\sqrt{5}} \left[ \left( \frac{1+\sqrt{5}}{2} \right)^0 - \left( \frac{1-\sqrt{5}}{2} \right)^0 \right]
= \frac{1}{\sqrt{5}} \left[ 1 - 1 \right] = \frac{0}{\sqrt{5}} = 0
$$

Para $n=1$ vemos que también se cumple

$$
\begin{aligned}
F_1 &= \frac{1}{\sqrt{5}} \left[ \left( \frac{1+\sqrt{5}}{2} \right)^1 - \left( \frac{1-\sqrt{5}}{2} \right)^1 \right] \\
&= \frac{1}{\sqrt{5}} \left[ \frac{1+\sqrt{5}-1+\sqrt{5}}{2} \right] \\
&= \frac{1}{\sqrt{5}} \left[ \frac{2\sqrt{5}}{2} \right] = \frac{\sqrt{5}}{\sqrt{5}} = 1
\end{aligned}
$$

Ahora supongamos que se cumple para $n=k$ y $n=k-1$ para algún $k$, vamos a demostrar que se cumple para $n=k+1$
